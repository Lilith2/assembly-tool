using AsmResolver.DotNet;
using AssemblyLib.Models;
using AssemblyLib.ReMapper;
using AssemblyLib.Utils;
using SPTarkov.DI.Annotations;

namespace AssemblyLib.AutoMatcher;

[Injectable(InjectionType.Singleton)]
public class AutoMatcher(
	MappingController mappingController,
	AssemblyUtils assemblyUtils
	)
{
	private ModuleDefinition? Module { get; set; }
	private List<TypeDefinition>? CandidateTypes { get; set; }
	
	private static readonly List<string> TypesToMatch = DataProvider.Settings.TypeNamesToMatch;
	
	private string? _newTypeName;
	
	public async Task AutoMatch(
		string assemblyPath, 
		string oldAssemblyPath, 
		string oldTypeName, 
		string newTypeName, 
		bool isRegen
		)
	{
		var result = assemblyUtils.TryDeObfuscate(
			DataProvider.LoadModule(assemblyPath), assemblyPath);

		_newTypeName = newTypeName;
		
		assemblyPath = result.Item1;
		Module = result.Item2;
		
		var targetTypeDef = FindTargetType(oldTypeName);
		
		if (targetTypeDef is null)
		{
			Logger.Log($"Could not target type: {oldTypeName}", ConsoleColor.Red);
			return;
		}
		Logger.Log($"Found target type: {targetTypeDef.FullName}", ConsoleColor.Green);
		
		GetCandidateTypes(targetTypeDef);
		Logger.Log($"Found {CandidateTypes?.Count ?? 0} potential candidates: {targetTypeDef.FullName}", ConsoleColor.Green);
		
		var remapModel = new RemapModel()
		{
			NewTypeName = newTypeName,
			AutoGenerated = true
		};
		
		await StartFilter(targetTypeDef, remapModel, assemblyPath, oldAssemblyPath, isRegen);
	}

	private TypeDefinition? FindTargetType(
		string oldTypeName
		)
	{
		return Module!.GetAllTypes().FirstOrDefault(t => t.FullName == oldTypeName);
	}

	private void GetCandidateTypes(
		TypeDefinition targetTypeDef
		)
	{
		if (targetTypeDef.IsNested)
		{
			CandidateTypes = targetTypeDef.DeclaringType?.NestedTypes
				.Where(t => TypesToMatch.Any(token => t.Name!.StartsWith(token)))
				.ToList();
			
			return;
		}
		
		CandidateTypes = Module?.GetAllTypes()
			.Where(t => TypesToMatch.Any(token => t.Name!.StartsWith(token)))
			.ToList();
	}
	
	private async Task StartFilter(
		TypeDefinition target, 
		RemapModel remapModel, 
		string assemblyPath, 
		string oldAssemblyPath, 
		bool isRegen
		)
	{
		Logger.Log($"Starting Candidates: {CandidateTypes!.Count}", ConsoleColor.Yellow);

		var filters = new TypeFilters(CandidateTypes);
		
		// Purpose of this pass is to eliminate any types that have no matching parameters
		foreach (var candidate in CandidateTypes!.ToList())
		{
			filters.Filter(target, candidate, remapModel);
		}
		
		if (CandidateTypes!.Count == 1)
		{
			await RunTest(remapModel, assemblyPath, oldAssemblyPath, isRegen);
			return;
		}
		
		Logger.Log("Could not find a match... :(", ConsoleColor.Red);
	}

	private async Task RunTest(
		RemapModel remapModel, 
		string assemblyPath, 
		string oldAssemblyPath, 
		bool isRegen
		)
	{
		Logger.Log("Narrowed candidates down to one. Testing generated model...", ConsoleColor.Green, true);
			
		DataProvider.Remaps.Clear();
		DataProvider.Remaps.Add(remapModel);
		await mappingController.Run(assemblyPath, string.Empty, validate: true);

		if (remapModel.Succeeded)
		{
			await ProcessEndQuestions(remapModel, assemblyPath, oldAssemblyPath, isRegen);
		}
	}
	
	private async Task ProcessEndQuestions(
		RemapModel remapModel, 
		string assemblyPath, 
		string oldAssemblyPath, 
		bool isRegen
		)
	{
		Thread.Sleep(1000);
		
		Logger.Log("Add remap to existing list?.. (y/n)", ConsoleColor.Yellow);
		var resp = Console.ReadLine()?.ToLower();

		if (string.IsNullOrEmpty(resp)) return;
		
		AddNewMappingToList(resp, remapModel, isRegen);
		
		Logger.Log("Would you like to run the remap process?... (y/n)", ConsoleColor.Yellow);
		var resp2 = Console.ReadLine()?.ToLower();
		
		if (string.IsNullOrEmpty(resp2)) return;
		
		await RunMappingProcess(resp2, assemblyPath, oldAssemblyPath);
	}

	private void AddNewMappingToList(
		string response, 
		RemapModel remapModel,
		bool isRegen
		)
	{
		if (response != "y" && response != "yes") return;
		
		DataProvider.Remaps.Clear();
		DataProvider.LoadMappingFile();

		// Remove the remap so we can re-add it
		if (isRegen && _newTypeName is not null)
		{
			var remap = DataProvider.Remaps.First(r => r.NewTypeName == _newTypeName);
			DataProvider.Remaps.Remove(remap);
		}
		
		if (DataProvider.Remaps.Any(m => m.NewTypeName == remapModel.NewTypeName))
		{
			Logger.Log($"Ambiguous new type names found for {remapModel.NewTypeName}. Please pick a different name.", ConsoleColor.Red);
			return;
		}
			
		DataProvider.Remaps.Add(remapModel);
		DataProvider.UpdateMapping(false, true);
	}

	private async Task RunMappingProcess(
		string response, 
		string assemblyPath, 
		string oldAssemblyPath
		)
	{
		if (response != "y" && response != "yes") return;
		
		var outPath = Path.GetDirectoryName(assemblyPath);

		if (outPath is null)
		{
			throw new DirectoryNotFoundException($"Could not resolve directory for `{assemblyPath}`");
		}
			
		await mappingController.Run(assemblyPath, oldAssemblyPath, outPath);
	}
}