using AsmResolver.DotNet;
using AssemblyLib.Models;
using AssemblyLib.ReMapper;
using AssemblyLib.Utils;

namespace AssemblyLib.AutoMatcher;

public class AutoMatcher
{
	private ModuleDefinition? Module { get; set; }
	private List<TypeDefinition>? CandidateTypes { get; set; }
	
	private static readonly List<string> TypesToMatch = DataProvider.Settings.TypeNamesToMatch;
	
	public async Task AutoMatch(string assemblyPath, string oldAssemblyPath, string oldTypeName, string newTypeName)
	{
		var result = AssemblyUtils.TryDeObfuscate(
			DataProvider.LoadModule(assemblyPath), assemblyPath);

		assemblyPath = result.Item1;
		Module = result.Item2;
		
		var targetTypeDef = FindTargetType(oldTypeName);
		
		if (targetTypeDef is null)
		{
			Logger.Log($"Could not target type: {oldTypeName}", ConsoleColor.Red);
			return;
		}
		Logger.Log($"Found target type: {targetTypeDef.FullName}", ConsoleColor.Green);
		
		GetCandidateTypes(targetTypeDef);
		Logger.Log($"Found {CandidateTypes?.Count ?? 0} potential candidates: {targetTypeDef.FullName}", ConsoleColor.Green);
		
		var remapModel = new RemapModel()
		{
			NewTypeName = newTypeName,
			AutoGenerated = true
		};
		
		await StartFilter(targetTypeDef, remapModel, assemblyPath, oldAssemblyPath);
	}

	private TypeDefinition? FindTargetType(string oldTypeName)
	{
		return Module!.GetAllTypes().FirstOrDefault(t => t.FullName == oldTypeName);
	}

	private void GetCandidateTypes(TypeDefinition targetTypeDef)
	{
		if (targetTypeDef.IsNested)
		{
			CandidateTypes = targetTypeDef.DeclaringType?.NestedTypes
				.Where(t => TypesToMatch.Any(token => t.Name!.StartsWith(token)))
				.ToList();
			
			return;
		}
		
		CandidateTypes = Module?.GetAllTypes()
			.Where(t => TypesToMatch.Any(token => t.Name!.StartsWith(token)))
			.ToList();
	}
	
	private async Task StartFilter(TypeDefinition target, RemapModel remapModel, string assemblyPath, string oldAssemblyPath)
	{
		Logger.Log($"Starting Candidates: {CandidateTypes!.Count}", ConsoleColor.Yellow);

		var filters = new TypeFilters(CandidateTypes);
		
		// Purpose of this pass is to eliminate any types that have no matching parameters
		foreach (var candidate in CandidateTypes!.ToList())
		{
			filters.Filter(target, candidate, remapModel);
		}
		
		if (CandidateTypes!.Count == 1)
		{
			await RunTest(remapModel, assemblyPath, oldAssemblyPath);
			return;
		}
		
		Logger.Log("Could not find a match... :(", ConsoleColor.Red);
	}

	private static async Task RunTest(RemapModel remapModel, string assemblyPath, string oldAssemblyPath)
	{
		Logger.Log("Narrowed candidates down to one. Testing generated model...", ConsoleColor.Green, true);
			
		DataProvider.Remaps.Clear();
		DataProvider.Remaps.Add(remapModel);
		await new MappingController(assemblyPath).Run(string.Empty, validate: true);

		if (remapModel.Succeeded)
		{
			await ProcessEndQuestions(remapModel, assemblyPath, oldAssemblyPath);
		}
	}
	
	private static async Task ProcessEndQuestions(RemapModel remapModel, string assemblyPath, string oldAssemblyPath)
	{
		Thread.Sleep(1000);
		
		Logger.Log("Add remap to existing list?.. (y/n)", ConsoleColor.Yellow);
		var resp = Console.ReadLine()?.ToLower();

		if (string.IsNullOrEmpty(resp)) return;
		
		AddNewMappingToList(resp, remapModel);
		
		Logger.Log("Would you like to run the remap process?... (y/n)", ConsoleColor.Yellow);
		var resp2 = Console.ReadLine()?.ToLower();
		
		if (string.IsNullOrEmpty(resp2)) return;
		
		await RunMappingProcess(resp2, assemblyPath, oldAssemblyPath);
	}

	private static void AddNewMappingToList(string response, RemapModel remapModel)
	{
		if (response != "y" && response != "yes") return;
		
		DataProvider.Remaps.Clear();
		DataProvider.LoadMappingFile();
			
		if (DataProvider.Remaps.Any(m => m.NewTypeName == remapModel.NewTypeName))
		{
			Logger.Log($"Ambiguous new type names found for {remapModel.NewTypeName}. Please pick a different name.", ConsoleColor.Red);
			return;
		}
			
		DataProvider.Remaps.Add(remapModel);
		DataProvider.UpdateMapping(false, true);
	}

	private static async Task RunMappingProcess(string response, string assemblyPath, string oldAssemblyPath)
	{
		if (response != "y" && response != "yes") return;
		
		var outPath = Path.GetDirectoryName(assemblyPath);

		if (outPath is null)
		{
			throw new DirectoryNotFoundException($"Could not resolve directory for `{assemblyPath}`");
		}
			
		await new MappingController(assemblyPath).Run(oldAssemblyPath, outPath);
	}
}