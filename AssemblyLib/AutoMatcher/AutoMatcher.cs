using System.Reflection;
using AsmResolver.DotNet;
using AssemblyLib.Models;
using AssemblyLib.ReMapper;
using AssemblyLib.Utils;
using Serilog;
using SPTarkov.DI.Annotations;

namespace AssemblyLib.AutoMatcher;

[Injectable(InjectionType.Singleton)]
public class AutoMatcher(
	MappingController mappingController,
	AssemblyUtils assemblyUtils,
	DataProvider dataProvider,
	TypeFilters typeFilter
	)
{
	private ModuleDefinition? Module { get; set; }
	private List<TypeDefinition>? CandidateTypes { get; set; }
	private List<string>? TypesToMatch;
	
	private string? _newTypeName;
	
	public async Task AutoMatch(
		string assemblyPath, 
		string oldAssemblyPath, 
		string oldTypeName, 
		string newTypeName, 
		bool isRegen
		)
	{
		var result = assemblyUtils.TryDeObfuscate(
			dataProvider.LoadModule(assemblyPath), assemblyPath);

		TypesToMatch = dataProvider.Settings.TypeNamesToMatch;
		
		_newTypeName = newTypeName;
		
		assemblyPath = result.Item1;
		Module = result.Item2;
		
		var targetTypeDef = FindTargetType(oldTypeName);
		
		if (targetTypeDef is null)
		{
			Log.Error("Could not target type: {OldTypeName}", oldTypeName);
			return;
		}
		Log.Information("Found target type: {FullName}", targetTypeDef.FullName);
		
		GetCandidateTypes(targetTypeDef);
		Log.Information(
			"Found {CandidateTypesCount} potential candidates: {FullName}", 
			CandidateTypes?.Count ?? 0, 
			targetTypeDef.FullName
			);
		
		var remapModel = new RemapModel()
		{
			NewTypeName = newTypeName,
			AutoGenerated = true
		};
		
		await StartFilter(targetTypeDef, remapModel, assemblyPath, oldAssemblyPath, isRegen);
	}

	private TypeDefinition? FindTargetType(
		string oldTypeName
		)
	{
		return Module!.GetAllTypes().FirstOrDefault(t => t.FullName == oldTypeName);
	}

	private void GetCandidateTypes(
		TypeDefinition targetTypeDef
		)
	{
		if (targetTypeDef.IsNested)
		{
			CandidateTypes = targetTypeDef.DeclaringType?.NestedTypes
				.Where(t => TypesToMatch.Any(token => t.Name!.StartsWith(token)))
				.ToList();
			
			return;
		}
		
		CandidateTypes = Module?.GetAllTypes()
			.Where(t => TypesToMatch.Any(token => t.Name!.StartsWith(token)))
			.ToList();
	}
	
	private async Task StartFilter(
		TypeDefinition target, 
		RemapModel remapModel, 
		string assemblyPath, 
		string oldAssemblyPath, 
		bool isRegen
		)
	{
		Log.Information("Starting Candidates: {Count}", CandidateTypes!.Count);
		
		// Purpose of this pass is to eliminate any types that have no matching parameters
		foreach (var candidate in CandidateTypes!.ToList())
		{
			typeFilter.Filter(target, candidate, remapModel);
		}
		
		if (CandidateTypes!.Count == 1)
		{
			await RunTest(remapModel, assemblyPath, oldAssemblyPath, isRegen);
			return;
		}
		
		Log.Error("Could not find a match... :(");
	}

	private async Task RunTest(
		RemapModel remapModel, 
		string assemblyPath, 
		string oldAssemblyPath, 
		bool isRegen
		)
	{
		Log.Information("Narrowed candidates down to one. Testing generated model...");
			
		DataProvider.Remaps.Clear();
		DataProvider.Remaps.Add(remapModel);
		await mappingController.Run(assemblyPath, string.Empty, validate: true);

		if (remapModel.Succeeded)
		{
			await ProcessEndQuestions(remapModel, assemblyPath, oldAssemblyPath, isRegen);
		}
	}
	
	private async Task ProcessEndQuestions(
		RemapModel remapModel, 
		string assemblyPath, 
		string oldAssemblyPath, 
		bool isRegen
		)
	{
		Thread.Sleep(1000);
		
		Log.Information("Add remap to existing list?.. (y/n)");
		var resp = Console.ReadLine()?.ToLower();

		if (string.IsNullOrEmpty(resp)) return;
		
		AddNewMappingToList(resp, remapModel, isRegen);
		
		Log.Information("Would you like to run the remap process?... (y/n)");
		var resp2 = Console.ReadLine()?.ToLower();
		
		if (string.IsNullOrEmpty(resp2)) return;
		
		await RunMappingProcess(resp2, assemblyPath, oldAssemblyPath);
	}

	private void AddNewMappingToList(
		string response, 
		RemapModel remapModel,
		bool isRegen
		)
	{
		if (response != "y" && response != "yes") return;
		
		DataProvider.Remaps.Clear();
		dataProvider.LoadMappingFile();

		// Remove the remap so we can re-add it
		if (isRegen && _newTypeName is not null)
		{
			var remap = DataProvider.Remaps.First(r => r.NewTypeName == _newTypeName);
			DataProvider.Remaps.Remove(remap);
		}
		
		if (DataProvider.Remaps.Any(m => m.NewTypeName == remapModel.NewTypeName))
		{
			Log.Information(
				"Ambiguous new type names found for {RemapModelNewTypeName}. Please pick a different name.", 
				remapModel.NewTypeName
				);
			return;
		}
			
		DataProvider.Remaps.Add(remapModel);
		dataProvider.UpdateMapping(false, true);
	}

	private async Task RunMappingProcess(
		string response, 
		string assemblyPath, 
		string oldAssemblyPath
		)
	{
		if (response != "y" && response != "yes") return;
		
		var outPath = Path.GetDirectoryName(assemblyPath);

		if (outPath is null)
		{
			throw new DirectoryNotFoundException($"Could not resolve directory for `{assemblyPath}`");
		}
			
		await mappingController.Run(assemblyPath, oldAssemblyPath, outPath);
	}
}